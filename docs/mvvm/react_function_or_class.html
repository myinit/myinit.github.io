<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>函数式组件与类组件有何不同？ | 前端知识</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="Mokou,源码解析,前端,Vue,Vue3,Es6,Javascript">
    <link rel="preload" href="/assets/css/0.styles.34d67128.css" as="style"><link rel="preload" href="/assets/js/app.da5e5cab.js" as="script"><link rel="preload" href="/assets/js/2.2bc50b5c.js" as="script"><link rel="preload" href="/assets/js/41.ec6f1a3e.js" as="script"><link rel="prefetch" href="/assets/js/10.5afa6c98.js"><link rel="prefetch" href="/assets/js/11.7159faba.js"><link rel="prefetch" href="/assets/js/12.04b47d5c.js"><link rel="prefetch" href="/assets/js/13.33237a86.js"><link rel="prefetch" href="/assets/js/14.ab167d38.js"><link rel="prefetch" href="/assets/js/15.98949b39.js"><link rel="prefetch" href="/assets/js/16.4a2bdd8a.js"><link rel="prefetch" href="/assets/js/17.31ad3a0f.js"><link rel="prefetch" href="/assets/js/18.41427e8c.js"><link rel="prefetch" href="/assets/js/19.471930fa.js"><link rel="prefetch" href="/assets/js/20.34609147.js"><link rel="prefetch" href="/assets/js/21.454fc426.js"><link rel="prefetch" href="/assets/js/22.94fc50ce.js"><link rel="prefetch" href="/assets/js/23.7da09a58.js"><link rel="prefetch" href="/assets/js/24.0708c613.js"><link rel="prefetch" href="/assets/js/25.7d734217.js"><link rel="prefetch" href="/assets/js/26.dbba15b6.js"><link rel="prefetch" href="/assets/js/27.fbf70cd3.js"><link rel="prefetch" href="/assets/js/28.e2474813.js"><link rel="prefetch" href="/assets/js/29.efb48b7f.js"><link rel="prefetch" href="/assets/js/3.1a9e0b8f.js"><link rel="prefetch" href="/assets/js/30.6cd4682a.js"><link rel="prefetch" href="/assets/js/31.b60aceb1.js"><link rel="prefetch" href="/assets/js/32.2be0b486.js"><link rel="prefetch" href="/assets/js/33.4180f091.js"><link rel="prefetch" href="/assets/js/34.c7a0ccf0.js"><link rel="prefetch" href="/assets/js/35.fc05f6e0.js"><link rel="prefetch" href="/assets/js/36.b02d62d1.js"><link rel="prefetch" href="/assets/js/37.870aa908.js"><link rel="prefetch" href="/assets/js/38.112e270d.js"><link rel="prefetch" href="/assets/js/39.e2b199b9.js"><link rel="prefetch" href="/assets/js/4.d571c79c.js"><link rel="prefetch" href="/assets/js/40.4b21c256.js"><link rel="prefetch" href="/assets/js/42.273a4070.js"><link rel="prefetch" href="/assets/js/43.195685f8.js"><link rel="prefetch" href="/assets/js/44.f23320bf.js"><link rel="prefetch" href="/assets/js/45.09676a4b.js"><link rel="prefetch" href="/assets/js/46.cb90e599.js"><link rel="prefetch" href="/assets/js/47.fe86ee10.js"><link rel="prefetch" href="/assets/js/48.e94890fd.js"><link rel="prefetch" href="/assets/js/49.ae3206b3.js"><link rel="prefetch" href="/assets/js/5.e24a0e2b.js"><link rel="prefetch" href="/assets/js/50.cbeb8f9a.js"><link rel="prefetch" href="/assets/js/51.6f3224f5.js"><link rel="prefetch" href="/assets/js/52.33c6e3ad.js"><link rel="prefetch" href="/assets/js/53.4ff5a34a.js"><link rel="prefetch" href="/assets/js/54.d384ca17.js"><link rel="prefetch" href="/assets/js/55.85a8de1d.js"><link rel="prefetch" href="/assets/js/56.02e6b73d.js"><link rel="prefetch" href="/assets/js/57.9c31601f.js"><link rel="prefetch" href="/assets/js/58.0d966891.js"><link rel="prefetch" href="/assets/js/59.18ce1da1.js"><link rel="prefetch" href="/assets/js/6.b6109b4f.js"><link rel="prefetch" href="/assets/js/60.b744966b.js"><link rel="prefetch" href="/assets/js/61.129cbf85.js"><link rel="prefetch" href="/assets/js/62.9552e4d5.js"><link rel="prefetch" href="/assets/js/63.d9b6fd4b.js"><link rel="prefetch" href="/assets/js/64.b6d27059.js"><link rel="prefetch" href="/assets/js/65.bc7da6ff.js"><link rel="prefetch" href="/assets/js/66.dd5aa73e.js"><link rel="prefetch" href="/assets/js/67.83dac889.js"><link rel="prefetch" href="/assets/js/68.94ad7166.js"><link rel="prefetch" href="/assets/js/69.55386e01.js"><link rel="prefetch" href="/assets/js/7.650cad16.js"><link rel="prefetch" href="/assets/js/70.315595ca.js"><link rel="prefetch" href="/assets/js/71.f4e03dbc.js"><link rel="prefetch" href="/assets/js/72.0580633e.js"><link rel="prefetch" href="/assets/js/8.76ea1f77.js"><link rel="prefetch" href="/assets/js/9.6594a171.js">
    <link rel="stylesheet" href="/assets/css/0.styles.34d67128.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/mh.jpg" alt="前端知识" class="logo"> <span class="site-name can-hide">前端知识</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue2 &amp;&amp; React</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/resource-analysis/fiber.html" class="sidebar-link">Fiber 源码解析</a></li><li><a href="/resource-analysis/vue2.html" class="sidebar-link">Vue 2.x 源码解析</a></li><li><a href="/mvvm/react.html" class="sidebar-link">React 简况</a></li><li><a href="/mvvm/useEffect.html" class="sidebar-link">翻译：React useEffect完全指南</a></li><li><a href="/mvvm/react_function_or_class.html" aria-current="page" class="active sidebar-link">翻译：React函数组件心智模型</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Flutter实战</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>服务端相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>简单的API</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="函数式组件与类组件有何不同？"><a href="#函数式组件与类组件有何不同？" class="header-anchor">#</a> 函数式组件与类组件有何不同？</h1> <p>与React类组件相比，React函数式组件究竟有何不同？</p> <p><a href="https://github.com/ryardley/hooks-perf-issues/pull/2" target="_blank" rel="noopener noreferrer">参考1:作者github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render" target="_blank" rel="noopener noreferrer">参考2：官网：<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>一般的回答都是：</p> <ol><li>类组件比函数式组件多了更多的特性，比如 <code>state</code>，那如果有 <code>Hooks</code> 之后呢？</li> <li>函数组件性能比类组件好，<strong>但是在现代浏览器中，闭包和类的原始性能只有在极端场景下才会有明显的差别。</strong> <ol><li>性能主要取决于代码的作用，而不是选择函数式还是类组件。尽管优化策略有差别，但性能差异可以忽略不计。</li></ol></li></ol> <p>而下面会重点讲述：React的函数式组件和类组件之间根本的区别： 在<strong>心智模型</strong>上。</p> <h3 id="简单的案例"><a href="#简单的案例" class="header-anchor">#</a> 简单的案例</h3> <p>函数式组件以经常被忽略的点：<strong>函数式组件捕获了渲染所用的值。（Function components capture the rendered values.）</strong></p> <p>思考这个组件:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">ProfilePage</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">showMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'你好 '</span> <span class="token operator">+</span> props<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>showMessage<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Follow</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">}</span>
</code></pre></div><p>上述组件：如果 <code>props.user</code>是 <code>Dan</code>，它会在三秒后显示 <code>你好 Dan</code>。</p> <p>如果是类组件我们怎么写？一个简单的重构可能就象这样：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">ProfilePage</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">showMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Followed '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>showMessage<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Follow</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通常我们认为，这两个代码片段是等效的。人们经常在这两种模式中自由的重构代码，但是很少注意到它们的含义：</p> <p><strong>我们通过 React 应用程序中的一个常见错误来说明其中的不同。</strong></p> <p>我们添加一个父组件，用一个下拉框来更改传递给子组件(<code>ProfilePage</code>)，的 <code>props.user</code>，实例地址：(https://codesandbox.io/s/pjqnl16lm7) 。</p> <p>按步骤完成以下操作：</p> <ol><li><strong>点击</strong> 其中某一个 Follow 按钮。</li> <li>在3秒内 <strong>切换</strong> 选中的账号。</li> <li><strong>查看</strong> 弹出的文本。</li></ol> <p>这时会得到一个奇怪的结果：</p> <ul><li>当使用 <strong>函数式组件</strong> 实现的 <code>ProfilePage</code>, 当前账号是 Dan 时点击 Follow 按钮，然后立马切换当前账号到 Sophie，弹出的文本将依旧是 <code>'Followed Dan'</code>。</li> <li>当使用 <strong>类组件</strong> 实现的 <code>ProfilePage</code>, 弹出的文本将是 <code>'Followed Sophie'</code>：</li></ul> <p>在这个例子中，函数组件是正确的。 <strong>如果我关注一个人，然后导航到另一个人的账号，我的组件不应该混淆我关注了谁。</strong> ，而类组件的实现很明显是错误的。</p> <h3 id="案例解析"><a href="#案例解析" class="header-anchor">#</a> 案例解析</h3> <p>所以为什么我们的例子中类组件会有这样的表现？ 让我们仔细看看类组件中的 <code>showMessage</code> 方法：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>  <span class="token function-variable function">showMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Followed '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这个类方法从 <code>this.props.user</code> 中读取数据。</p> <ol><li>在 React 中 Props 是 不可变(immutable)的，所以他们永远不会改变。</li> <li>而 <code>this</code> 是而且永远是 可变(mutable)的。**</li></ol> <p>这也是类组件 <code>this</code> 存在的意义：能在渲染方法以及生命周期方法中得到最新的实例。</p> <p>所以如果在请求已经发出的情况下我们的组件进行了重新渲染， <code>this.props</code>将会改变。 <code>showMessage</code>方法从一个&quot;过于新&quot;的 <code>props</code>中得到了 <code>user</code>。</p> <p>从 this 中读取数据的这种行为，调用一个回调函数读取 <code>this.props</code> 的 timeout 会让 <code>showMessage</code> 回调并没有与任何一个特定的渲染&quot;绑定&quot;在一起，所以它&quot;失去&quot;了正确的 props。。</p> <h3 id="如何用类组件解决上述bug？（假设函数式组件不存在）"><a href="#如何用类组件解决上述bug？（假设函数式组件不存在）" class="header-anchor">#</a> 如何用类组件解决上述BUG？（假设函数式组件不存在）</h3> <p>我们想要以某种方式&quot;修复&quot;拥有正确 props 的渲染与读取这些 props 的 <code>showMessage</code>回调之间的联系。在某个地方 <code>props</code>被弄丢了。</p> <h5 id="方法一：在调用事件之前读取-this-props，然后显式地传递到timeout回调函数中："><a href="#方法一：在调用事件之前读取-this-props，然后显式地传递到timeout回调函数中：" class="header-anchor">#</a> 方法一：在调用事件之前读取 <code>this.props</code>，然后显式地传递到timeout回调函数中：</h5> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">ProfilePage</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">showMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Followed '</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>user<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">showMessage</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Followbutton&gt;;
  }
}
</span></code></pre></div><p>然而，这种方法使得代码明显变得更加冗长。如果我们需要的不止是一个props 该怎么办？ 如果我们还需要访问state 又该怎么办？ **如果 <code>showMessage</code> 调用了另一个方法，然后那个方法中读取了 <code>this.props.something</code> 或者 <code>this.state.something</code> ，我们又将遇到同样的问题。**然后我们不得不将 <code>this.props</code>和 <code>this.state</code>以函数参数的形式在被 <code>showMessage</code>调用的每个方法中一路传递下去。</p> <p>这样的做法破坏了类提供的工程学。同时这也很难让人去记住传递的变量或者强制执行，这也是为什么人们总是在解决bugs。</p> <p>这个问题可以在任何一个将数据放入类似 <code>this</code> 这样的可变对象中的UI库中重现它（不仅只存在 React 中）</p> <h5 id="方法二：如果我们能利用javascript闭包的话问题将迎刃而解。"><a href="#方法二：如果我们能利用javascript闭包的话问题将迎刃而解。" class="header-anchor">#</a> 方法二：如果我们能利用JavaScript闭包的话问题将迎刃而解。*</h5> <p>如果你在一次特定的渲染中捕获那一次渲染所用的props或者state，你会发现他们总是会保持一致，就如同你的预期那样：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">ProfilePage</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token function-variable function">showMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Followed '</span> <span class="token operator">+</span> props<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span>showMessage<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Follow</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>你在渲染的时候就已经&quot;捕获&quot;了props：</strong>。这样，在它内部的任何代码（包括 <code>showMessage</code>）都保证可以得到这一次特定渲染所使用的props。</p> <h3 id="hooks-的由来"><a href="#hooks-的由来" class="header-anchor">#</a> Hooks 的由来</h3> <p>但是：如果你在 <code>render</code>方法中定义各种函数，而不是使用class的方法，那么使用类的意义在哪里？</p> <p>事实上，我们可以通过删除类的&quot;包裹&quot;来简化代码：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">ProfilePage</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">showMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Followed '</span> <span class="token operator">+</span> props<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>showMessage<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Follow</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>就像上面这样， <code>props</code>仍旧被捕获了 —— React将它们作为参数传递。 <strong>不同于 <code>this</code> ， <code>props</code> 对象本身永远不会被React改变。</strong></p> <p>当父组件使用不同的props来渲染 <code>ProfilePage</code>时，React会再次调用 <code>ProfilePage</code>函数。但是我们点击的事件处理函数，&quot;属于&quot;具有自己的 <code>user</code>值的上一次渲染，并且 <code>showMessage</code>回调函数也能读取到这个值。它们都保持完好无损。</p> <p>这就是为什么，在上面那个的函数式版本中，点击关注账号1，然后改变选择为账号2，仍旧会弹出 <code>'Followed 账号1'</code>：</p> <blockquote><p><strong>函数式组件捕获了渲染所使用的值。</strong></p></blockquote> <p><strong>使用Hooks，同样的原则也适用于state。</strong> 看这个例子：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">MessageThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>message<span class="token punctuation">,</span> setMessage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">showMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'You said: '</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleSendClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>showMessage<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleMessageChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleMessageChange<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleSendClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Send</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果我发送一条特定的消息，组件不应该对实际发送的是哪条消息感到困惑。这个函数组件的 <code>message</code>变量捕获了&quot;属于&quot;返回了被浏览器调用的单击处理函数的那一次渲染。所以当我点击&quot;发送&quot;时 <code>message</code>被设置为那一刻在input中输入的内容。</p> <h3 id="读取最新的状态"><a href="#读取最新的状态" class="header-anchor">#</a> 读取最新的状态</h3> <p>因此我们知道，在默认情况下React中的函数会捕获props和state。 **但是如果我们想要读取并不属于这一次特定渲染的，最新的props和state呢？**如果我们想要[&quot;从未来读取他们&quot;]呢？</p> <p>在类中，你通过读取 <code>this.props</code>或者 <code>this.state</code>来实现，因为 <code>this</code>本身时可变的。React改变了它。在函数式组件中，你也可以拥有一个在所有的组件渲染帧中共享的可变变量。它被成为&quot;ref&quot;：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><p>但是，你必须自己管理它。</p> <p>一个ref与一个实例字段扮演同样的角色。这是进入可变的命令式的世界的后门。你可能熟悉'DOM refs'，但是ref在概念上更为广泛通用。它只是一个你可以放东西进去的盒子。</p> <p>甚至在视觉上， <code>this.something</code>就像是 <code>something.current</code>的一个镜像。他们代表了同样的概念。</p> <p>默认情况下，React不会在函数式组件中为最新的props和state创造refs。在很多情况下，你并不需要它们，并且分配它们将是一种浪费。但是，如果你愿意，你可以这样手动地来追踪这些值：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">MessageThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>message<span class="token punctuation">,</span> setMessage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> latestMessage <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">showMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'You said: '</span> <span class="token operator">+</span> latestMessage<span class="token punctuation">.</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleSendClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>showMessage<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleMessageChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    latestMessage<span class="token punctuation">.</span>current <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>如果我们在 <code>showMessage</code>中读取 <code>message</code>，我们将得到在我们按下发送按钮那一刻的信息。但是当我们读取 <code>latestMessage.current</code>，我们将得到最新的值 —— 即使我们在按下发送按钮后继续输入。</p> <p>ref是一种&quot;选择退出&quot;渲染一致性的方法，在某些情况下会十分方便。</p> <p>通常情况下，你应该避免在渲染期间读取或者设置refs，因为它们是可变得。我们希望保持渲染的可预测性。 **然而，如果我们想要特定props或者state的最新值，那么手动更新ref会有些烦人。**我们可以通过使用一个effect来自动化实现它：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">MessageThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>message<span class="token punctuation">,</span> setMessage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> latestMessage <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    latestMessage<span class="token punctuation">.</span>current <span class="token operator">=</span> message<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">showMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'You said: '</span> <span class="token operator">+</span> latestMessage<span class="token punctuation">.</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们在一个effect 内部执行赋值操作以便让ref的值只会在DOM被更新后才会改变。这确保了我们的变量突变不会破坏依赖于可中断渲染的时间切片和 Suspense 等特性。</p> <p>通常来说使用这样的ref并不是非常地必要。 <strong>捕获props和state通常是更好的默认值。</strong> 然而，在处理类似于intervals和订阅这样的命令式API时，ref会十分便利。你可以像这样跟踪 任何值 —— 一个prop，一个state变量，整个props对象，或者甚至一个函数。</p> <p>这种模式对于优化来说也很方便 —— 例如当 <code>useCallback</code>本身经常改变时。然而，使用一个reducer 通常是一个更好的解决方式</p> <p>闭包帮我们解决了很难注意到的细微问题。同样，它们也使得在并发模式下能更轻松地编写能够正确运行的代码。这是可行的，因为组件内部的逻辑在渲染它时捕获并包含了正确的props和state。</p> <p>函数捕获了他们的props和state —— 因此它们的标识也同样重要。这不是一个bug，而是一个函数式组件的特性。例如，对于 <code>useEffect</code>或者 <code>useCallback</code>来说，函数不应该被排除在&quot;依赖数组&quot;之外。（正确的解决方案通常是使用上面说过的 <code>useReducer</code>或者 <code>useRef</code> ）</p> <p>当我们用函数来编写大部分的React代码时，我们需要调整关于<a href="https://github.com/ryardley/hooks-perf-issues/pull/3" target="_blank" rel="noopener noreferrer">优化代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="noopener noreferrer">什么变量会随着时间改变<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的认知与直觉。</p> <blockquote><p>到目前为止，我发现的有关于hooks的最好的心里规则是&quot;写代码时要认为任何值都可以随时更改&quot;。</p></blockquote> <p>React函数总是捕获他们的值 —— 现在我们也知道这是为什么了。</p> <p>文章参考：React作者 Dan Abramov 的github</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/mvvm/useEffect.html" class="prev">
        翻译：React useEffect完全指南
      </a></span> <span class="next"><a href="/browser/security_code.html">
        前端安全性
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.da5e5cab.js" defer></script><script src="/assets/js/2.2bc50b5c.js" defer></script><script src="/assets/js/41.ec6f1a3e.js" defer></script>
  </body>
</html>
