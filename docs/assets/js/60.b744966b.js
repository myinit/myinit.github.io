(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{427:function(_,v,e){"use strict";e.r(v);var t=e(42),a=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"js-数据类型篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-数据类型篇"}},[_._v("#")]),_._v(" JS-数据类型篇")]),_._v(" "),e("h3",{attrs:{id:"基础类型有哪些？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础类型有哪些？"}},[_._v("#")]),_._v(" 基础类型有哪些？")]),_._v(" "),e("p",[_._v("基本类型有七种")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("null")])]),_._v(" "),e("li",[e("code",[_._v("undefined")])]),_._v(" "),e("li",[e("code",[_._v("boolean")])]),_._v(" "),e("li",[e("code",[_._v("number")])]),_._v(" "),e("li",[e("code",[_._v("string")])]),_._v(" "),e("li",[e("code",[_._v("symbol")]),_._v("（较新标准）")]),_._v(" "),e("li",[e("code",[_._v("BigInt")]),_._v("（新标准）")])]),_._v(" "),e("p",[e("code",[_._v("NaN")]),_._v(" 也属于 "),e("code",[_._v("number")]),_._v(" 类型，并且 "),e("code",[_._v("NaN")]),_._v(" 不等于自身")]),_._v(" "),e("h3",{attrs:{id:"基础类型的特性是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础类型的特性是什么？"}},[_._v("#")]),_._v(" 基础类型的特性是什么？")]),_._v(" "),e("ol",[e("li",[_._v("基本类型的值是保存在"),e("code",[_._v("栈内存")]),_._v("中的简单数据段")]),_._v(" "),e("li",[_._v("基础类型是"),e("code",[_._v("不可变的")]),_._v(" "),e("ul",[e("li",[_._v("即不能强行修改："),e("code",[_._v("Array.prototype.sort.call('abc');")]),_._v("(会报错)")])])]),_._v(" "),e("li",[_._v("基础类型上没有"),e("code",[_._v("__proto__")]),_._v("没有"),e("code",[_._v("属性")])]),_._v(" "),e("li",[_._v("基础类型可以通过 "),e("code",[_._v("基本包装类型")]),_._v(" 访问的属性/方法"),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("    // 通过包装类型访问基础类型特性\n    let str = 'abc';\n    console.log(str.length)\n\n    // 当你调用 `str.length` 时，实际过程是这样的：\n    // -> 创建String类型的一个实例\n    // -> 在实例上调用指定的方法\n    // -> 销毁这个实例\n\n    let _str = new String(str);\n    let len = _str.length;\n    _str = null;\n")])])])])]),_._v(" "),e("h3",{attrs:{id:"怎么检测基础类型？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎么检测基础类型？"}},[_._v("#")]),_._v(" 怎么检测基础类型？")]),_._v(" "),e("ol",[e("li",[_._v("检测基础类型可以用 "),e("code",[_._v("typeof")]),_._v("，但是 "),e("code",[_._v("typeof null === 'object'")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("null")]),_._v(" 是基础类型，不是 Object")]),_._v(" "),e("li",[_._v("由于null的历史遗留问题(前三位为000)，所以使用"),e("code",[_._v("typeof")]),_._v("检测null会产生BUG")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("    // 借鉴 Vue 源码的 object 检测方法\n    function isObject (obj: any): Boolean {\n        return obj !== null && typeof obj === 'object'\n    }\n")])])])]),_._v(" "),e("li",[_._v("通过 "),e("code",[_._v("Object.prototype.toString.call")]),_._v(" （万能方法）\n"),e("ul",[e("li",[_._v("检测 "),e("code",[_._v("[[class]]")])]),_._v(" "),e("li",[_._v("在不覆盖 toString 方法前提下，任何一个对象调用 Object 原生的 toString 方法都会返回 "),e("code",[_._v("[object type]")])])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("    // 借鉴 Vue 源码的检测方法\n\n    let _toString = Object.prototype.toString;\n\n    function toRawType (value: any): String {\n        // 获取 从第九个到倒数第二个 字符\n        // 比如 [object String]  获取 String\n        return _toString.call(value).slice(8, -1)\n    }\n")])])])])]),_._v(" "),e("h3",{attrs:{id:"基础类型是如何转换的？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础类型是如何转换的？"}},[_._v("#")]),_._v(" 基础类型是如何转换的？")]),_._v(" "),e("ol",[e("li",[_._v("基本类型转换时，首先会调用 "),e("code",[_._v("valueOf")]),_._v("，然后调用 "),e("code",[_._v("toString")]),_._v("。(这两个方法可以被重写)")]),_._v(" "),e("li",[_._v("在四则运算中，除了 "),e("code",[_._v("+")]),_._v(" 其他操作都会以数字进行计算，如果是 "),e("code",[_._v("+")]),_._v(" 运算，如果不是所有字面量"),e("strong",[_._v("都是")]),e("code",[_._v("number")]),_._v("（都是number就是数字的加法咯），那么会转换为字符串("),e("code",[_._v("toString")]),_._v(")进行拼接")])]),_._v(" "),e("h3",{attrs:{id:"为什么-0-1-0-2-为什么不等于-0-3-？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么-0-1-0-2-为什么不等于-0-3-？"}},[_._v("#")]),_._v(" 为什么 0.1 + 0.2 为什么不等于 0.3 ？")]),_._v(" "),e("p",[_._v("遵循"),e("code",[_._v("IEEE 754 双精度版本（64位）")]),_._v("标准的语言都有的问题。计算机无法识别十进制，JS会将十进制转换为对应的二进制（二进制即："),e("code",[_._v("0")]),_._v(" 和 "),e("code",[_._v("1")]),_._v("）。")]),_._v(" "),e("p",[_._v("那么 怎么用 "),e("code",[_._v("0")]),_._v(" 和 "),e("code",[_._v("1")]),_._v(" 来表示 "),e("code",[_._v("0.1")]),_._v(" 和 "),e("code",[_._v("0.2")]),_._v(" 呢？")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("    console.log(0.1.toString(2));\n    // -> 0.0001100110011001100110011001100110011001100110011001101\n\n    console.log(0.2.toString(2));\n    // -> 0.001100110011001100110011001100110011001100110011001101\n")])])]),e("p",[_._v("这样看似没问题啊。为什么会有BUG呢？")]),_._v(" "),e("p",[_._v("别忘了：JS的精确度区间 约为正负 "),e("code",[_._v("2^53")]),_._v("，超出限制会截断。所以你看到的 0.1 不是真的 0.1。")]),_._v(" "),e("h3",{attrs:{id:"那么怎么解决-js-的精确度问题？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#那么怎么解决-js-的精确度问题？"}},[_._v("#")]),_._v(" 那么怎么解决 JS 的精确度问题？")]),_._v(" "),e("ol",[e("li",[_._v("目前主流的解决方案是 "),e("code",[_._v("先乘再除")]),_._v(" "),e("ul",[e("li",[_._v("比如精确到小数点后2位")]),_._v(" "),e("li",[_._v("先把需要计算的数字都 乘1000")]),_._v(" "),e("li",[_._v("计算完成后再把结果  除1000")])])]),_._v(" "),e("li",[_._v("使用新基础类型 "),e("code",[_._v("BigInt")]),_._v(" (兼容性很差)")])]),_._v(" "),e("h3",{attrs:{id:"js的-真-值有哪些？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js的-真-值有哪些？"}},[_._v("#")]),_._v(' JS的"真"值有哪些？')]),_._v(" "),e("p",[_._v('JS中除了 "假" 值以外就是 "真" 值。')]),_._v(" "),e("p",[_._v('"假"值包括 7 个')]),_._v(" "),e("ol",[e("li",[e("code",[_._v("undefined")])]),_._v(" "),e("li",[e("code",[_._v("null")])]),_._v(" "),e("li",[e("code",[_._v("false")])]),_._v(" "),e("li",[e("code",[_._v("NaN")])]),_._v(" "),e("li",[e("code",[_._v("''")])]),_._v(" "),e("li",[e("code",[_._v("0")])]),_._v(" "),e("li",[e("code",[_._v("-0")])])]),_._v(" "),e("p",[_._v('在条件判断的隐式转换中："假" 值会转换为 '),e("code",[_._v("false")]),_._v('，"真" 值会转换为 '),e("code",[_._v("true")]),_._v(";")]),_._v(" "),e("h3",{attrs:{id:"那说一下引用类型吧？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#那说一下引用类型吧？"}},[_._v("#")]),_._v(" 那说一下引用类型吧？")]),_._v(" "),e("ol",[e("li",[_._v("除了基础类型，都是引用类型。")]),_._v(" "),e("li",[_._v("引用类型正在创建时会分配"),e("code",[_._v("两个空间")]),_._v(" "),e("ul",[e("li",[_._v("一块在"),e("code",[_._v("堆")]),_._v("上，储存引用类型本身的数据（当然数据量会比较大）")]),_._v(" "),e("li",[_._v("一块在"),e("code",[_._v("栈")]),_._v("上，储存对"),e("code",[_._v("堆")]),_._v("上数据的引用（存储堆上的内存地址，也就是指针）")])])]),_._v(" "),e("li",[_._v("引用类型是可变的：即"),e("code",[_._v("let a={}; a.x=1;")])]),_._v(" "),e("li",[_._v("function参数是值传递，要注意不能修改引用")])]),_._v(" "),e("h3",{attrs:{id:"怎么检测引用类型？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎么检测引用类型？"}},[_._v("#")]),_._v(" 怎么检测引用类型？")]),_._v(" "),e("ol",[e("li",[_._v("通过 "),e("code",[_._v("Object.prototype.toString.call")]),_._v(" 检测 "),e("code",[_._v("[[class]]")])]),_._v(" "),e("li",[_._v("通过 "),e("code",[_._v("instanceof")]),_._v(" 判断引用类型")]),_._v(" "),e("li",[_._v("通过 "),e("code",[_._v("constructor")]),_._v(" 判断引用类型（"),e("code",[_._v("constructor")]),_._v("是可写的，慎用）")])]),_._v(" "),e("h3",{attrs:{id:"instanceof-的原理是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#instanceof-的原理是什么？"}},[_._v("#")]),_._v(" instanceof 的原理是什么？")]),_._v(" "),e("p",[e("code",[_._v("instanceof")]),_._v(" 内部机制是通过"),e("strong",[_._v("判断对象的原型链中是不是能找到对应的的"),e("code",[_._v("prototype")])])]),_._v(" "),e("p",[_._v("所以在验证iframe时会有BUG，因为 "),e("code",[_._v("window.Array.prototype !== window.frames[0].Array.prototype")]),_._v("，所以不存在继承关系")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("  // 实现 instanceof\n\n  function instanceof(obj, target) {\n      // 获得对象的原型\n      obj = obj.__proto__\n      // 判断对象的类型是否等于类型的原型\n      while (true) {\n        // 如果__proto__ === null 说明原型链遍历完毕\n        if (obj === null) {\n          return false\n        }\n        // 如果存在 obj.__proto__ === target.prototype\n        // 说明对象是该类型的实例\n        if (obj === target.prototype) {\n          return true\n        }\n        // 原型链上查找\n        obj = obj.__proto__\n      }\n  }\n")])])]),e("h3",{attrs:{id:"如果用-instanceof-判断基础类型会怎么样？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果用-instanceof-判断基础类型会怎么样？"}},[_._v("#")]),_._v(" 如果用 instanceof 判断基础类型会怎么样？")]),_._v(" "),e("p",[_._v("会返回 "),e("code",[_._v("false")]),_._v(" 因为基础类型没有 "),e("code",[_._v("__proto__")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("    let str = '123';\n\n    console.log(str instanceof String) // -> false\n")])])]),e("p",[_._v("但是如果更改了 静态方法"),e("code",[_._v("Symbol.hasInstance")]),_._v("就可以判断了")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("    class StringType {\n        static [Symbol.hasInstance](val) {\n            return typeof val === 'string'\n        }\n    }\n    console.log(str instanceof StringType) // -> true\n")])])]),e("h3",{attrs:{id:"说一下数组吧？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下数组吧？"}},[_._v("#")]),_._v(" 说一下数组吧？")]),_._v(" "),e("p",[_._v("数组是一种类列表对象，其数据在内存中也可以不连续")]),_._v(" "),e("p",[_._v("数组应该是一段线性分配的内存，但是JS的Array的检索和更新方式和对象一模一样")]),_._v(" "),e("ul",[e("li",[_._v("Array它把下标变成"),e("strong",[_._v("数字")]),_._v("，用其作属性。"),e("strong",[_._v("它比真正的数组慢")]),_._v("，但用起来更方便。")]),_._v(" "),e("li",[_._v("Array本质还是对象，其原型继承自"),e("code",[_._v("Array.prototype")]),_._v("，向上再继承自"),e("code",[_._v("Object.prototype")])]),_._v(" "),e("li",[_._v("Array的方法是设计为对象通用的，对象也能调用数组的方法"),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("    let obj = {\n        '2': 3,\n        '3': 4,\n        'length': 2,\n        'splice': Array.prototype.splice,\n        'push': Array.prototype.push\n    }\n    obj.push(1)\n    obj.push(2)\n\n    console.log(obj);\n    // Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]\n")])])])]),_._v(" "),e("li",[_._v("使用"),e("code",[_._v("delete arr[2]")]),_._v("，并不能减少length，而只是删除了对应的属性（变成empty）")])]),_._v(" "),e("h3",{attrs:{id:"什么是类数组？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是类数组？"}},[_._v("#")]),_._v(" 什么是类数组？")]),_._v(" "),e("ol",[e("li",[_._v("类数组不是数组，通过 "),e("code",[_._v("Array.isArray()")]),_._v(" 会返回 "),e("code",[_._v("false")])]),_._v(" "),e("li",[_._v("类数组通过 "),e("code",[_._v("Array.from")]),_._v(" 可以转换为数组")]),_._v(" "),e("li",[_._v("属性要为索引（数字）属性")]),_._v(" "),e("li",[_._v("必须有length属性")])]),_._v(" "),e("p",[_._v("经常遇见的类数组")]),_._v(" "),e("ul",[e("li",[_._v("字符串\n"),e("ul",[e("li",[_._v("唯一的原生类数组")])])]),_._v(" "),e("li",[e("code",[_._v("arguments")]),_._v(" "),e("ul",[e("li",[_._v("arguments完全可以使用"),e("code",[_._v("...args")]),_._v("代替，这样不定参数就是真数组")]),_._v(" "),e("li",[_._v("arguments在箭头函数中被移除")])])]),_._v(" "),e("li",[_._v("DOM")])]),_._v(" "),e("h3",{attrs:{id:"结果是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结果是什么？"}},[_._v("#")]),_._v(" [] == ![] 结果是什么？")]),_._v(" "),e("p",[_._v("类型转换都是先 "),e("code",[_._v("valueOf")]),_._v(" 再 "),e("code",[_._v("toString")]),_._v(";")]),_._v(" "),e("p",[_._v("右边")]),_._v(" "),e("ol",[e("li",[_._v("由于 "),e("code",[_._v("!")]),_._v(" 优先级比 "),e("code",[_._v("==")]),_._v(" 高，先执行 "),e("code",[_._v("!")])]),_._v(" "),e("li",[e("code",[_._v("![]")]),_._v(" 得到 false")]),_._v(" "),e("li",[_._v("进行 "),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness",target:"_blank",rel:"noopener noreferrer"}},[_._v("相等性判断"),e("OutboundLink")],1)]),_._v(" "),e("li",[e("code",[_._v("false")]),_._v(" 转化为数字 "),e("code",[_._v("0")])])]),_._v(" "),e("p",[_._v("左边")]),_._v(" "),e("ol",[e("li",[_._v("执行 "),e("code",[_._v("[].valueOf()")]),_._v(" 原始值 还是 []")]),_._v(" "),e("li",[_._v("执行 [].toString() 得到 ''")]),_._v(" "),e("li",[e("code",[_._v("''")]),_._v(" 转化为数字 "),e("code",[_._v("0")])])]),_._v(" "),e("p",[_._v("所以："),e("code",[_._v("0 == 0")]),_._v(" ，答案是 "),e("code",[_._v("true")])]),_._v(" "),e("p",[_._v("验证：")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("    let arr1 = [];\n    let arr2 = [];\n\n    console.log(arr1 == !arr2) // -> true\n\n    arr1.toString = () => {\n        console.log(111)\n        return 1\n    }\n\n    console.log(arr1 == !arr2) \n    // -> 111\n    // -> false\n")])])]),e("h3",{attrs:{id:"和-的区别-？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别-？"}},[_._v("#")]),_._v(" == 和 === 的区别 ？")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("===")]),_._v(" 不进行隐式转换")]),_._v(" "),e("li",[e("code",[_._v("==")]),_._v(" 会进行隐式转换\n"),e("ul",[e("li",[e("code",[_._v('{a: 1} == "[object Object]"')]),_._v(" 左边会执行 "),e("code",[_._v(".toString()")])])])])]),_._v(" "),e("h3",{attrs:{id:"如何让-a-1-a-2-条件成立？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何让-a-1-a-2-条件成立？"}},[_._v("#")]),_._v(" 如何让 (a == 1 && a == 2)条件成立？")]),_._v(" "),e("p",[_._v("依然是类型转换逻辑：基础类型通过 "),e("code",[_._v("valueOf")]),_._v(" 进行隐式转换")]),_._v(" "),e("p",[_._v("更改 "),e("code",[_._v("valueOf")]),_._v(" 方法就可以实现")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("    let a = {\n        value: 0,\n        valueOf: function() {\n            this.value++;\n            return this.value;\n        }\n    };\n    console.log(a == 1 && a == 2);\n")])])]),e("h3",{attrs:{id:"object-is-和-的区别-？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-is-和-的区别-？"}},[_._v("#")]),_._v(" "),e("code",[_._v("Object.is")]),_._v(" 和 === 的区别 ？")]),_._v(" "),e("p",[e("code",[_._v("Object.is(v1, v2)")]),_._v(" 修复了 "),e("code",[_._v("===")]),_._v(" 的一些BUG "),e("code",[_._v("(-0和+0, NaN和NaN)")]),_._v("：")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("    // === 案例\n    -0 === +0       // -> true\n    NaN !== NaN     // -> false\n\n    Object.is(-0, +0)       // -> false\n    Object.is(NaN, NaN)     // -> true\n")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);